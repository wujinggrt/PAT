# Family Property

id 那么就是并查集。

比如 5551 家族：有 6666 5552 7777 一共 4 个人。 1  100， 2 300，所以计算是 3 / 4 = 0.750, 400 / 4 = 100.000.

每次输入一个人的时候，就把他相关的人都添加，然后在按照最小的 id 来使用并查集。

先遍历一遍，保存所有名字到并查集。

然后在重新遍历一遍，更新并查集？

#### 柳神

并查集操作是为了显示 id、，所以操作只进行 id 的大小比较。

然后遍历一遍，is_root[find_root(i)].people++ 就可以得到这一个家族有多少人了，也就是数并查集人数。

#### 思路

首先输入，然后把所有人（包括父母，子女）的 id 保存下来到一个 vector，在使用一个 map 来保存这些人的 id 在 vector 的索引，然后使用下一次遍历进行并查集操作的时候可以通过这个 map 来索引，随后，在使用父母 id 不等于 "-1" 的时候才会被保存。如果已经在 map 中了也不会被保存。

然后在重新遍历一遍输入过的 n 各大小的当事人数组，在遍历他的关系的每一个人，使用并查集操作，使用 id 来判断谁是 root，方便最后输出。

上一次已经得到了最终的 root 了，但是有些结点可能还没有挂载到最终 root，而是次级的。所以再次遍历那些所有的 ids 的 vector，目的是实际的确定 root，确定 root id，确定 root 的人数，在放到 map 上映射到一个 struct Root，which 保存着 id, num_people, num, area 的信息。然后这次就更新了前两个。

这次在遍历一次 people，找出那个人的所有资产，加到 root 上面去。

遍历 map，建立一个指针的 vector，指向 map 中由 root 的 id 的索引映射到的 Root，然后在对这一对指针排序，最后可以输出。

