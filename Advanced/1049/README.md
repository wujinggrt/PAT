# Counting Ones

使用O(n)的遍历会超时，需要优化掉那些不含1的。比如02-09, 22-30, 32-40。

然后使用to_string，在使用count函数，完成。

[reference](https://www.cnblogs.com/0kk470/p/8075133.html)

这是新的题型，套路。

找规律题，计算每一位对应的1的个数，然后相加，每一位的1的计算情况分三种情况：

1.如果当前位数字为0，那么该位的1的个数由更高位的数字确定。比如2120，个位为1的个数为212 * 1 = 212（个位的单位为1）。比如：1,11,21,...,2111。一共就有212个了。

2.如果当前位数字为1，那么该位的1的个数不但由高位决定，还由低位数字决定。比如2120百位为1，那么百位数字1的个数为2 * 100 + 20 + 1 = 221个（百位的单位为100）。比如：2100-2119,2120就是20 + 1。然后2 * 100就是 0100-0199和1100-1199,一共200个。

3.如果当前位数字大于1，那么该位数字1的个数为（高位数+ 1） * 位数单位。比如2120十位为2，那么十位数字1的个数为（21 + 1） * 10 = 220个（十位的单位为10）。21*10就是10-19,110-119,...2010-2019,一共21组。大于1，就是多出来的factor个。，221[0-9]组。

4.继续按照上文，2120千位为2，那么千位为1的个数为（0 + 1）*1000 = 1000

5.综上2120以内的所有数字中出现1的个数为1653个。
