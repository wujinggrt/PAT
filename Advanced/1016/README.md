使用的数据结构是`map`，给`map`传入`std::less<string>`作为比较器，能依据传入的名字进行比较大小，从而根据这个排序按顺序输出。

时间使用`string`来存储，`string`能够通过ascii比较大小，所以传入的时间可以比较大小，不用转换数据类型。

保存用户的通话记录，即是操作电话的时间，on-line, off-line保存在CallRecord里面。这是一个一维数组，输入完成后，传入比较器，根据时间来排序通话记录（包括on-line等信息随着CallDate一起排序）。

遍历这个map，使用`adjacent_find`，查找两个相邻的on_line, off_line。前后顺序不能打乱，能够在vector<CallDate>找到的话，就是存在一条完整的通话，将其记录下。然后迭代器`it`前进两个单位，即是`off-line`之后。如果不是end，继续比较，查找出的结果存储到`bills`中，我们最终需要打印的结果。

需要注意的点：
1. 尽管保证每个用户存在输入，但是这个输入不一定有效。也就是他的`bills`消费可能为0，这种情况不应print下来。
2. on-line一定与off-line相邻，在off-line的左边。如果没有这种情况，其他的都不算有效数据。

`prices`的计算方法：有天、小时、分钟计算出总共有多少分钟，然后两种情况：
1. on-line的分钟+总分钟小于等于60，那么简单的乘以costs，输出结果。、
2. on-line的分钟+总分钟大于60，那么找到这个差值，乘以它，随后增加hour，然后计算出每个hour的花费。

使用`to_next_minute`记录到下一分钟需要多久，使用循环来完成。

最后的bills保存的结果：

    | - 名字和月份
    | - vector<CallRecord> call_data，保存的是通话的时间、本次通话分钟，花费
    | - 总花费