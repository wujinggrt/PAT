如果使用Adjacent Matrix来表示图，那么在情况N = 10000的时候，会申请内存100M,内存爆掉。在测试点3会不通过。所以使用Adjacent List来表示这个无向图。但是这个方法会在测试点3消耗很多时间，逼近1s。

#### 使用dfs暴力解决

使用Adjacent List存储边的信息，然后第一个dfs用来判断连通分量的个数。

第二个dfs用来穷举从每个点出发，最长的深度是多少。如果最长或者相等，flag set。然后push_back。并且伴随着回溯，剪枝。

#### 使用并查集(Disjoined set?)和两次dfs

[https://blog.csdn.net/qq_26398495/article/details/81625961](https://blog.csdn.net/qq_26398495/article/details/81625961)

并查集判断连通图。

第一次任选一个结点作为根，找出它的最深的叶节点（存在集合）；第二次以集合A中任一点作为根再找出最深叶节点（继续存入）；两次集合的并集即为最深根节点集合。

这样确实省去了暴力搜索的时间消耗，但是Why does it make sense?

证明：

在第一次dfs从u出发，那么在v点是这颗tree以u为root的最深点。v必定不为路途中的结点。

第二次dfs从v出发，找到另外一个最深的叶子节点w。w肯定不会在u ~ v之间。因为如果存在u ~ w ~ v，那么w就不是最深的叶子节点。**故最深的叶子节点必为w**。（对于整个图而言，不知一个w的情况也是容易证明）。

    w <- u -> v
    v -> u -> w

      u 
     / \
    w   v_1 
         \
          v