# Tree Traversals Again

中序遍历的特性是：左子树，root，右子树。那么就可以把中序遍历从`root`拆分成左右部分，递归下去就可以了。所以对于中序遍历的问题剩下找root。而先序遍历是root，左子树，右子树。所以先序遍历就直接按顺序来，在从中序遍历中搜索，就可以找出中序遍历中的root了。

通过第一次进入root，那么就已经知道了**先序遍历**，随后就是**中序遍历**。利用这两个顺序来还原。

从pre的最左边得到root，在对应到中序，得到左子树和root。递归。

以先序的顺序遍历过去。

比如这题：

    pre: 1 2 3 4 5 6
    in: 3 2 4 1 6 5

第一次：root:1，然后在对应到inorder中的1，完成第一个root。左子树为：

    pre: 2 3 4
    in: 3 2 4

2就是左子树的root，左子树部分为，然后继续：

    pre: 2 3
    in 3 2

得到2是root，在继续：

    pre: 3
    in 3

这就是左子树的root。接下来右子树了。递归。

#### 代码的实现思路：

递归函数，接受`left, right, root_pos_in_preorder`。其中`left`和`right`来判断区间是否有效。
