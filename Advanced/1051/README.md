# Pop Sequence

找规律，stack的特征，FILO，所以出来的，至少大于等于先进去的。

两个错误类型：超过m和乱序。

先模拟stack？因为两次stack的入出栈就可以还原顺序。

首先push一个数字，然后一直pop到，直到大于他的数字，or m(5)个。恰小于第一个数字（最后push到stack的那个）每一段必须是降序，都是pop的。3 2 1 是，但是7 5 6 4的6位子错了。

首先读取一个数字，以这个数字作为栈顶，随后一直读取（push如我们的栈）到一个大于他的数字，作为新的栈顶来处理。

如果遇到大的数字，那就先考虑，比他小的数字压到了stack，比如：

1. 3，2，1, 4的话3 < 4，就压3，2，1，压入紧跟的<=3(第一个)的数字。
2. 1，2，3的顺序，那么push 1,pop 1, push 2, pop 2. 我们只保留当前栈（最大5）和出栈的记录。
3. 5 6 4 3 7 2 1。比如5后紧跟的6，5 < 6，那么就只压入5.因为只push了5，然后又push了6 4 3，所以后面在check 5之后，check 6 4 3是降序（用stack记录的话就是升序）。然后最后stack剩下7 2 1，OK。
4. 如果超过了5，false。

总体来说，我们只check 每一次题目给的pop的顺序，是否是降序，使用stack来记录这些pop的顺序。   

测试点2总是过不去，原来是自己在stack的size那儿，写成了5，而不是m。改正后ac。

[reference](https://blog.csdn.net/fried123123/article/details/82320445)

分析：

发现遇到了较大的数字（指代大于idx的数字），那么意味着压栈了，接下来的行为可以为两种cases:

    直接pop，3，2，1。
    也许，push，在pop。3，4，2，1。

    其中不可能为7 5 6 4，因为7这种越级的数，代表7之前的数字比如6已经push过了。并且还没有pop的情况下，自然在比他小的数之前pop。而6在7之后pop，说明push，那么7之后，5，的话，6在5和7之间，必然是早就pop了。

