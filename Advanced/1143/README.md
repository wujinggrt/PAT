# Lowest Common Ancestor

使用 map 来确定查询的是否出现在 BST 之中。

pre 的特性，前面的必然是后面的 root。不可能是孩子。将当前结点标记为a，如果u和v分别在a的左、右，或者u、v其中一个就是当前a。即(a >= u && a <= v) || (a >= v && a <= u)。因为可能不存在，所以才有 `>=`.

就是因为前序遍历，所以有当前遍历到的是 root，然后计算靠后的 NLR，LR。


  // a belongs to (u, v) or (v, u)
  // 因为 a 也就是寻找的 parent 必定属于
  // u, v 的区间，也就是作为 root, 左子树小于 a，右子树大于 a
  // 的特效
  // 利用道德一个 BST 肯定不满足的特效，左右子树不满足上述关系
  // 肯定就不是合适的 parent

  // w.l.o.g, 假设 u < v
        o // 它的右子树不满足要求，cur_node 不属于 [u, v]
       / \
      o // 这一个就是我们需要找的
     / \
    u   v

